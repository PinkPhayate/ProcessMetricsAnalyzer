public class MessageBuilder extends Task
{

    private static  final   String  TAB_STOP = "    ";
    
    private static  final   String  PROPERTIES_BOILERPLATE =
        "###################################################\n" +
        "#\n" +
        "# Licensed to the Apache Software Foundation (ASF) under one or more\n" +
        "# contributor license agreements.  See the NOTICE file distributed with\n" +
        "# this work for additional information regarding copyright ownership.\n" +
        "# The ASF licenses this file to You under the Apache License, Version 2.0\n" +
        "# (the \"License\"); you may not use this file except in compliance with\n" +
        "# the License.  You may obtain a copy of the License at\n" +
        "#\n" +
        "#\n" +
        "# Unless required by applicable law or agreed to in writing, software\n" +
        "# distributed under the License is distributed on an \"AS IS\" BASIS,\n" +
        "# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n" +
        "# See the License for the specific language governing permissions and\n" +
        "# limitations under the License.\n" +
        "#\n" +
        "###################################################\n" +
        "\n" +
        "###################################################\n" +
        "#\n" +
        "# DO NOT EDIT THIS FILE!\n" +
        "#\n" +
        "# Instead, edit messages.xml. The ant MessageBuilder task takes\n" +
        "# messages.xml as input and from it generates this file.\n" +
        "#\n" +
        "###################################################\n";

    private static  final   String  REF_GUIDE_BOILERPLATE =
        "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" +
        " \"../dtd/reference.dtd\">\n";

    private static  final   String  REF_GUIDE_NOTES =
        "<!-- \n" +
        "Licensed to the Apache Software Foundation (ASF) under one or more\n" +
        "contributor license agreements.  See the NOTICE file distributed with\n" +
        "this work for additional information regarding copyright ownership.\n" +
        "The ASF licenses this file to You under the Apache License, Version 2.0\n" +
        "(the \"License\"); you may not use this file except in compliance with\n" +
        "the License.  You may obtain a copy of the License at      \n" +
        "\n" +
        "\n" +
        "Unless required by applicable law or agreed to in writing, software  \n" +
        "distributed under the License is distributed on an \"AS IS\" BASIS,  \n" +
        "WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  \n" +
        "See the License for the specific language governing permissions and  \n" +
        "limitations under the License.\n" +
        "-->\n" +
        "\n" +
        "<!-- \n" +
        "NOTE: this file is generated by the MessageBuilder task as part of a\n" +
        "Derby build. Please do not hand-edit this file. Instead, please edit\n" +
        "the corresponding text in messages.xml and/or MessageBuilder.\n" +
        "-->\n";
    

    private String  _xmlSourceFile;
    private String  _propertiesTargetFile;
    private String  _ditaTargetFile;


    public  static  final   class   XMLWriter
    

    public MessageBuilder()
    {}
    

        
    public void setXmlSourceFile( String fileName ) { _xmlSourceFile = fileName;}

    public void setPropertiesTargetFile( String fileName ) { _propertiesTargetFile = fileName;}

    public void setDitaTargetFile( String fileName ) { _ditaTargetFile = fileName;}
        
    public  void    execute()
        throws BuildException
    {
        File                 source = new File( _xmlSourceFile );
        File                 targetProperties = new File( _propertiesTargetFile );
        File                 targetDita = new File( _ditaTargetFile );
        FileWriter      propertiesFW = null;
        PrintWriter    propertiesPW = null;
        XMLWriter    ditaWriter = null;

        try {
            propertiesFW = new FileWriter( targetProperties );
            propertiesPW = new PrintWriter( propertiesFW );
            ditaWriter = new XMLWriter( targetDita );

            processMessages( source, propertiesPW, ditaWriter );
        }
        catch (Exception e)
        {
            throw new BuildException( "Could not generate English properties from message descriptors: " + e.getMessage(), e );
        }
        finally
        {
            try {
                finishWriting( propertiesFW, propertiesPW );

                if ( ditaWriter != null )
                {
                    ditaWriter.flush();
                    ditaWriter.close();
                }
            }
            catch (Exception ex)
            {
                throw new BuildException( "Error closing file writers.", ex );
            }
        }
        
    }


    private void    processMessages( File input, PrintWriter propertiesPW, XMLWriter ditaWriter )
        throws Exception
    {
        DocumentBuilderFactory  factory = DocumentBuilderFactory.newInstance();
        DocumentBuilder              builder = factory.newDocumentBuilder();
        Document                          doc = builder.parse( input );
        NodeList                            sections = root.getElementsByTagName( "section" );             

        propertiesPW.println( PROPERTIES_BOILERPLATE );
        ditaWriter.println( REF_GUIDE_BOILERPLATE );

        ditaWriter.beginTag( "reference", "id=\"rrefexcept71493\" xml:lang=\"en-us\""  );
        {
            ditaWriter.println( REF_GUIDE_NOTES );
            ditaWriter.writeTextElement( "title", "SQL error messages and exceptions" );

            ditaWriter.beginTag( "refbody" );
            {
                ditaWriter.beginTag( "section" );
                {
                    ditaWriter.writeTextElement
                        (
                         "p",
                         "The following tables list <i>SQLStates</i> for exceptions. Exceptions " +
                         "that begin with an <i>X</i> are specific to <ph conref=\"../conrefs.dita#prod/productshortname\"></ph>."
                         );
                }
                ditaWriter.endTag();
                
                ditaWriter.beginTag( "section" );
                {
                    processSections( propertiesPW, ditaWriter, sections );
                }
                ditaWriter.endTag();
                
            }
            ditaWriter.endTag();
        }
        ditaWriter.endTag();
    }

    private void    processSections( PrintWriter propertiesPW, XMLWriter ditaWriter, NodeList nodes )
        throws Exception
    {
        int     nodeCount = nodes.getLength();
        
        for ( int i = 0; i < nodeCount; i++ )
        {
            Element     node = (Element) nodes.item( i );
            
            processSection( propertiesPW, ditaWriter, node );
        }
    }

    private void    processSection( PrintWriter propertiesPW, XMLWriter ditaWriter, Element section )
        throws Exception
    {
        boolean     documented = ( getFirstChild( section, "documented" ) != null );
        NodeList   families = section.getElementsByTagName( "family" );
        int             familyCount = families.getLength();

        if ( !documented ) { ditaWriter = new XMLWriter(); }

        for ( int i = 0; i < familyCount; i++ )
        {
            Element     family = (Element) families.item( i );
            
            processFamily( propertiesPW, ditaWriter, family );
        }
    }
    
    private void    processFamily( PrintWriter propertiesPW, XMLWriter ditaWriter, Element family )
        throws Exception
    {
        String        title = squeezeText( getFirstChild( family, "title" ) );
        NodeList   messages = family.getElementsByTagName( "msg" );
        int              messageCount = messages.getLength();

        ditaWriter.beginTag( "table" );
        {
            ditaWriter.writeTextElement( "title", title );
            ditaWriter.writeTextElement( "desc", "This table lists the SQLStates and message text for the " + title + " exceptions." );
            
            ditaWriter.beginTag( "tgroup", "cols=\"2\"" );
            {
                ditaWriter.writeEmptyTag( "colspec", "colname=\"col1\" colnum=\"1\" colwidth=\"1*\"" );
                ditaWriter.writeEmptyTag( "colspec", "colname=\"col2\" colnum=\"2\" colwidth=\"7.5*\"" );

                ditaWriter.beginTag( "thead" );
                {
                    ditaWriter.beginTag( "row", "valign=\"bottom\"" );
                    {
                        ditaWriter.writeTextElement( "entry", "colname=\"col1\"", "SQLSTATE" );
                        ditaWriter.writeTextElement( "entry", "colname=\"col2\"", "Message Text" );
                    }
                    ditaWriter.endTag();
                }
                ditaWriter.endTag();

                ditaWriter.beginTag( "tbody" );
                {
                    for ( int i = 0; i < messageCount; i++ )
                    {
                        Element     message = (Element) messages.item( i );
                        
                        processMessage( propertiesPW, ditaWriter, message );
                    }
                }
                ditaWriter.endTag();
            }
            ditaWriter.endTag();
        }
        ditaWriter.endTag();
    }
    
    private void    processMessage( PrintWriter propertiesPW, XMLWriter ditaWriter, Element message )
        throws Exception
    {
        String        name = squeezeText( getFirstChild( message, "name" ) );
        String        sqlstate = getSQLState( name );
        String        rawText = squeezeText( getFirstChild( message, "text" ) );
        String        propertyText = escapePropertiesText( rawText );
        int             parameterCount = countParameters( rawText );
        String[]     comments = getOptionalSubElements( message, "comment" );
        String[]     args = getOptionalSubElements( message, "arg" );

        if ( parameterCount != args.length )
        {
            throw new Exception( name + " has " + parameterCount + " parameters but " + args.length + " nested args." );
        }

        String displayText;
        if (rawText.indexOf('\'')>=0)
        {
            displayText = replaceSpecialChars( escapeTextWithAQuote( rawText ) );
            displayText = plugInArgs( displayText , args );
        }
        else
        {
            displayText = plugInArgs( replaceSpecialChars( rawText), args ) ;
        }

        ditaWriter.beginTag( "row" );
        {
            ditaWriter.writeTextElement( "entry", "colname=\"col1\"", sqlstate );
            ditaWriter.writeTextElement( "entry", "colname=\"col2\"", displayText );
        }
        ditaWriter.endTag();

        propertiesPW.println( "" );
        
        if ( comments.length != 0 )
        {
            for ( int i = 0; i < comments.length; i++ )
            {
                propertiesPW.println( "# " + comments[ i ] );
            }
            propertiesPW.println( "#" );
        }
        
        if ( args.length != 0 )
        {
            propertiesPW.println( "# Arguments:" );
            propertiesPW.println( "#" );
            for ( int i = 0; i < args.length; i++ )
            {
                propertiesPW.println( "#    {" + i + "} = " + args[ i ] );
            }
            propertiesPW.println( "#" );
        }
        propertiesPW.println( name + "=" + propertyText );
    }

    private String  getSQLState( String name )
    {
        if ( name.length() <= 5 ) { return name; }
        else { return name.substring( 0, 5 ); }
    }

    private String[]    getOptionalSubElements( Element message, String subElementTag )
        throws Exception
    {
        NodeList   options = message.getElementsByTagName( subElementTag );
        int             count = options.getLength();
        String[]    retval = new String[ count ];

        for ( int i = 0; i < count; i++ )
        {
            Element     option = (Element) options.item( i );
            
            retval[ i ] = squeezeText( option );
        }

        return retval;
    }

    private int countParameters( String text )
    {
        int     argCount = 0;
        int     argIdx = 0;

        while( true )
        {
            argIdx = text.indexOf( '{', argIdx );

            if ( argIdx >= 0 )
            {
                argCount++;
                argIdx++;
            }
            else { break; }
        }

        return argCount;
    }

    private String  plugInArgs( String message, String[] rawArgs )
    {
        int             count = rawArgs.length;
        String[]    cookedArgs = new String[ count ];
        MessageFormat format = new MessageFormat(message);

        for ( int i = 0; i < count; i++ )
        {
            cookedArgs[ i ] = "<varname>&lt;" + rawArgs[ i ] + "&gt;</varname>";
        }

        return format.format(cookedArgs);
    }


    private void    echo( String text )
    {
        log( text, Project.MSG_WARN );
    }

    private void    finishWriting( FileWriter fw, PrintWriter pw )
        throws IOException
    {
        if ( (fw == null) || (pw == null) ) { return; }
        
        pw.flush();
        fw.flush();

        pw.close();
        fw.close();
    }


    private Element getFirstChild( Element node, String childName )
        throws Exception
    {
        return (Element) node.getElementsByTagName( childName ).item( 0 );
    }

    private String squeezeText( Element node )
        throws Exception
    {
        Node        textChild = node.getFirstChild();
        String      text = textChild.getNodeValue();

        return text;
    }

    private static String replaceSpecialChars(java.lang.String input) {
        String output = input.replaceAll("<", "&lt;");
        output = output.replaceAll(">", "&gt;");
        
        return output;
    }


    private static String escapePropertiesText( java.lang.String input )
    {
        String output = input.replaceAll( "\n", "\\\\n" );

        output = output.replaceAll( "\'", "\'\'" );
        
        return output;
    }

    private static String escapeTextWithAQuote( java.lang.String input )
    {
        String output = input.replaceAll( "\'", "\'\'" );
        
        return output;
    }



}
